import json
import uuid
from unittest.mock import MagicMock

import pytest
from entitysdk.models import CellMorphology

# Assuming the endpoint logic is contained or uses functions from a module named
# morphology_metrics_calculation and morphology_validation. We will import and
# mock functions from these expected locations.
from app.dependencies.entitysdk import get_client
from app.endpoints.morphology_metrics_calculation import register_morphology, _run_morphology_analysis, _register_assets_and_measurements
from app.endpoints.morphology_validation import process_and_convert_morphology
from fastapi import UploadFile

# Define the route for the endpoint being tested
ROUTE = "/declared/morphology-metrics-entity-registration"


# --- Fixtures for Mock Data ---

@pytest.fixture
def mock_entity_payload():
    """Returns a mock JSON string payload for the CellMorphology entity."""
    return json.dumps({
        "cell_name": "Test Cell",
        "protocol_name": "Reconstruction Protocol",
        "subject_id": str(uuid.uuid4()),
        "brain_region_id": str(uuid.uuid4()),
        "brain_location": {"x": 100, "y": 200, "z": 300},
    })


@pytest.fixture
def mock_morphology_file():
    """Returns a mock UploadFile object for the SWC file upload."""
    return UploadFile(
        filename="test_morphology.swc",
        file=MagicMock()  # Mock the file content stream
    )


@pytest.fixture
def mock_temp_file_path():
    """Returns a mock path object for the temporary SWC file."""
    # We use a non-existent path as we only need to pass it to mocked functions
    return "/tmp/mock_temp_file.swc"


@pytest.fixture
def mock_measurement_list():
    """Returns a mock list of measurements generated by the analysis."""
    return [
        {"name": "total_length", "value": 500.0, "unit": "um", "domain": "soma"},
        {"name": "n_sections", "value": 10, "unit": "count", "domain": "apical_dendrite"},
    ]


# --- Test Case ---

def test_morphology_registration_success(
    client,
    monkeypatch,
    mock_entity_payload,
    mock_morphology_file,
    mock_temp_file_path,
    mock_measurement_list
):
    """
    Tests the successful registration and metrics calculation pipeline, ensuring
    all helper functions and API calls are mocked and correctly utilized.
    """
    # 1. Setup Mock EntitySDK Client
    entitysdk_client_mock = MagicMock()
    # Mocking the client override for dependency injection
    monkeypatch.setitem(client.app.dependency_overrides, get_client, lambda: entitysdk_client_mock)

    # Mock the ID returned after successful entity creation
    mock_entity_id = uuid.uuid4()
    mock_data = MagicMock(id=mock_entity_id)

    # 2. Mock Internal Pipeline Functions
    # Mock file processing: returns temp path and file content string
    def mock_process_and_convert(morphology_file, outputfile1=None):
        return mock_temp_file_path, "mock-content-string-swc-file"

    # Mock file conversion/validation
    monkeypatch.setattr(
        process_and_convert_morphology,
        mock_process_and_convert
    )

    # Mock morphology analysis: returns the list of metrics
    monkeypatch.setattr(
        _run_morphology_analysis,
        lambda path: mock_measurement_list
    )

    # Mock entity registration: returns the mock data object with entity ID
    monkeypatch.setattr(
        register_morphology,
        lambda client, payload: mock_data
    )

    # Mock asset/measurement registration: simply ensure it's called
    mock_register_assets_and_measurements = MagicMock()
    monkeypatch.setattr(
        _register_assets_and_measurements,
        mock_register_assets_and_measurements
    )

    # 3. Perform the POST Request
    response = client.post(
        ROUTE,
        data={
            "morphology_name": "Test Morphology 1",
            "content_type": "morphology/swc",
            "entity_payload": mock_entity_payload,
        },
        files={
            "morphology_file": ("test_morphology.swc", b"mock swc content", "application/octet-stream")
        }
    )

    # 4. Assertions

    # Check for success status code
    assert response.status_code == 200

    # Check response body content
    response_json = response.json()
    assert response_json["status"] == "success"
    assert response_json["entity_id"] == str(mock_entity_id)
    assert response_json["morphology_name"] == "Test Morphology 1"

    # Check that all registration steps were called correctly
    # Assert that asset/measurement registration was called with the correct ID and measurements
    mock_register_assets_and_measurements.assert_called_once()
    args, kwargs = mock_register_assets_and_measurements.call_args
    assert args[1] == str(mock_entity_id)  # entity_id is the second positional arg
    assert args[4] == mock_measurement_list  # measurement_list is the fifth positional arg

   